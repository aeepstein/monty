% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/packer.R
\name{mcstate_packer}
\alias{mcstate_packer}
\title{Build a parameter packer}
\usage{
mcstate_packer(scalar = NULL, array = NULL, fixed = NULL, process = NULL)
}
\arguments{
\item{scalar}{Names of scalar parameters.  This is similar for
listing elements in \code{array} with values of 1, though elements in
\code{scalar} will be placed ahead of those listed in \code{array} within
the final parameter vector, and elements in \code{array} will have
generated names that include square brackets.}

\item{array}{A list, where names correspond to the names of array
parameters and values correspond to the lengths of parameters.
Multiple dimensions are allowed (so if you provide an element
with two entries these represent dimensions of a matrix).  In
future, you may be able to use \emph{strings} as values for the
lengths, in which case these will be looked for within \code{fixed}.}

\item{fixed}{A named list of fixed parameters; these will be added
into the final list directly.  These typically represent
additional pieces of data that your model needs to run, but
which you are not performing inference on.}

\item{process}{An arbitrary R function that will be passed the
final assembled parameter list; it may create any \emph{additional}
entries, which will be concatenated onto the original list.  If
you use this you should take care not to return any values with
the same names as entries listed in \code{scalar}, \code{array} or
\code{fixed}, as this is an error (this is so that \code{pack()} is
not broken).  We will likely play around with this process in
future in order to get automatic differentiation to work.}
}
\value{
An object of class \code{mcstate_packer}, which has three
elements:
\itemize{
\item \code{parameters}: a character vector of computed parameter names;
these are the names that your statistical model will use.
\item \code{unpack}: a function that can unpack an unstructured vector
(say, from your statistical model parameters) into a structured
list (say, for your generative model)
\item \code{pack}: a function that can pack your structured list of
parameters back into a numeric vector suitable for the
statistical model.  This ignores values created by a
\code{preprocess} function.
\item \code{index}: a function which produces a named list where each
element has the name of a value in \code{parameters} and each value
has the indices within an unstructured vector where these values
can be found.
}
}
\description{
Build a parameter packer, which can be used in models to translate
between an unstructured vector of numbers (the vector being
updated by an MCMC for example) to a structured list of named
values, which is easier to program against.  We refer to the
process of taking a named list of scalars, vectors and arrays and
converting into a single vector "packing" and the inverse
"unpacking".
}
\details{
There are several places where it is most convenient to work in an
unstructured vector:
\itemize{
\item An MCMC is typically discussed as a the updating of some
vector \code{x} to another \verb{x'}
\item An optimisation algorithm will try and find a set of values for
a vector \code{x} that minimises (or maximises) some function \code{f(x)}
\item An ode solver works with a vector \code{x(t)} (\code{x} at time \code{t}) and
considers \code{x(t + h)} by computing the vector of derivatives
\code{dx(t)/dt}
}

In all these cases, the algorithm that needs the vector of numbers
knows nothing about what they represent.  Commonly, these will be
a packed vector of parameters.  So our vector \code{x} might actually
represent the parameters \code{a}, \code{b} and \code{c} in a vector as \verb{[a, b, c]} - this is a very common pattern, and you have probably
implemented this yourself.

In more complex settings, we might want our vector \code{x} to collect
more structured quantities.  Suppose that you are fitting a model
with an age-structured or sex-structured parameter.  Rather than
having a series of scalars packed into your vector \code{x} you might
have a series of values destined to be treated as a vector:

\if{html}{\out{<div class="sourceCode">}}\preformatted{| 1  2  3  4  5  6  7  |
| a  b  c  d1 d2 d3 d4 |
}\if{html}{\out{</div>}}

So here we might have a vector of length 7, where the first three
elements will represent be the scalar values \code{a}, \code{b} and \code{c} but
the next four will be a vector \code{d}.

Unpacked, this might be written as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{list(a = 1, b = 2, c = 3, d = 4:7)
}\if{html}{\out{</div>}}

The machinery here is designed to make these transformations
simple and standardised within mcstate2, and should be flexible
enough for many situations.  We will also use these from within
\code{dust2} and \code{odin2} for transformations in and out of vectors of
ODE state.
}
\section{When to use \code{process}}{
The \code{process} function is a get-out-of-jail function designed to
let you do arbitrary transformations when unpacking a vector.  In
general, this should not be the first choice to use because it is
less easy to reason about by other tooling (for example, as we
develop automatic differentiation support for use with the HMC
algorithm, a \code{process} function will be problematic because we
will need to make sure we can differentiate this process).
However, there are cases where it will be only way to achieve some
results.

Imagine that you are packing a 2x2 covariance matrix into your
vector in order to use within an MCMC or optimisation algorithm.
Ultimately, our unpacked vector will need to hold four elements
(\code{b11}, \code{b12}, \code{b21}, \code{b22}), but there are only three distinct
values as the two off-diagonal elements will be the same (i.e.,
\verb{b12 == b21``).  So we might write this passing in }b_raw = 3\code{to}array\verb{, so that our unpacked list holds }b_raw = c(b11, b12,
b22)\verb{.  We would then write }process` as something like:

\if{html}{\out{<div class="sourceCode">}}\preformatted{process <- function(x) \{
  list(b = matrix(x$b_raw[c(1, 2, 2, 3)], 2, 2))
\}
}\if{html}{\out{</div>}}

which creates the symmetric 2x2 matrix \code{b} from \code{b_raw}.
}

