% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampler-nested-random-walk.R
\name{mcstate_sampler_nested_random_walk}
\alias{mcstate_sampler_nested_random_walk}
\title{Nested Random Walk Sampler}
\usage{
mcstate_sampler_nested_random_walk(vcv, boundaries = "reflect")
}
\arguments{
\item{vcv}{A list of variance covariance matrices.  We expect this
to be a list with elements \code{base} and \code{groups} corresponding to
the covariance matrix for base parameters (if any) and groups.

##' @param boundaries Control the behaviour of proposals that are
outside the model domain.  The supported options are:
\itemize{
\item "reflect" (the default): we reflect proposed parameters that
lie outside the domain back into the domain (as many times as
needed)
\item "reject": we do not evaluate the density function, and return
\code{-Inf} for its density instead.
\item "ignore": evaluate the point anyway, even if it lies outside
the domain.
}

The initial point selected will lie within the domain, as this is
enforced by \link{mcstate_sample}.}
}
\value{
A \code{mcstate_sampler} object, which can be used with
\link{mcstate_sample}
}
\description{
Create a nested random walk sampler, which uses a symmetric
proposal for separable sections of a model to move around in
parameter space.  This sampler supports sampling from models where
the likelihood is only computable randomly (e.g., for pmcmc), and
requires that models support the \code{has_parameter_groups} property.
}
\details{
The intended use case for this sampler is for models where the
density can be decomposed at least partially into chunks that are
independent from each other.  Our motivating example for this is a
model of COVID-19 transmission where some parameters
region-specific (e.g., patterns and rates of contact between
individuals), and some parameters are shared across all regions
(e.g., intrinsic properties of the disease such as incubation
period).

The strategy is to propose all the shared parameters as a
deviation from the current point in parameter space as a single
move and accept or reject as a block. Then we generate points for
all the region-specific parameters, compute the density and then
accept or reject these updates independently.  This is possible
because the change in likelihood in region A is independent from
region B.

We expect that this approach will be beneficial in limited
situations, but where it is beneficial it is likely to result in
fairly large speedups:
\itemize{
\item You probably need more than three regions; as the number of
regions increases the benefit independently accepting or
rejecting densities increases (with 1000 separate regions your
chains will mix very slowly for example).
\item Your model is fairly comutationally heavy so that the density
calculation completely dominates the sampling process.
\item You do not have access to gradient information for your model;
we suspect that HMC will outperform this approach by some margin
because it already includes this independence via the gradients.
\item You can compute your independent calculations in parallel, which
help this method reduce your walk time.
}
}
