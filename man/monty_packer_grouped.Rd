% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/packer-grouped.R
\name{monty_packer_grouped}
\alias{monty_packer_grouped}
\title{Build a nested packer}
\usage{
monty_packer_grouped(
  groups,
  scalar = NULL,
  array = NULL,
  fixed = NULL,
  process = NULL,
  shared = NULL
)
}
\arguments{
\item{groups}{A character vector of group names.  These must not
be present within any of your \code{scalar} or \code{array} arguments.}

\item{scalar}{Names of scalars.  This is similar for listing
elements in \code{array} with values of 1, though elements in
\code{scalar} will be placed ahead of those listed in \code{array} within
the final parameter vector, and elements in \code{array} will have
generated names that include square brackets.}

\item{array}{A list, where names correspond to the names of arrays
and values correspond to their lengths.  Multiple dimensions are
allowed (so if you provide an element with two entries these
represent dimensions of a matrix).  Zero-length integer vectors
or \code{NULL} values are counted as scalars, which allows you to put
scalars at positions other than the front of the packing
vector. In future, you may be able to use \emph{strings} as values
for the lengths, in which case these will be looked for within
\code{fixed}.}

\item{fixed}{A named list of fixed data to be inserted into the
final unpacked list; these will be added into the final list
directly.  In the parameter packer context, these typically
represent additional pieces of data that your model needs to
run, but which you are not performing inference on.}

\item{process}{An arbitrary R function that will be passed the
final assembled list; it may create any \emph{additional} entries,
which will be concatenated onto the original list.  If you use
this you should take care not to return any values with the same
names as entries listed in \code{scalar}, \code{array} or \code{fixed}, as this
is an error (this is so that \code{pack()} is not broken).  We will
likely play around with this process in future in order to get
automatic differentiation to work.}

\item{shared}{Names of the elements in \code{scalar} and \code{array} that
are shared among all groups.}
}
\value{
An object of class \code{monty_packer_grouped}, which has the
same elements as \code{monty_packer}, though with slightly different
effects.
\itemize{
\item \code{names}: a function that returns a character vector of computed
names; in the parameter packer context these are the names that
your statistical model will use.
\item \code{groups}: A function that returns your group names (the \code{groups}
argument as supplied)
\item \code{unpack}: A function for converting between an unstructured
vector into a nested list.  Each element of this list is
conceptually the same as the resullt of \code{unpack()} from
\code{\link[=monty_packer]{monty_packer()}}.
\item \code{pack}: The inverse to \code{unpack()} but less commonly performed.
Convert a nested list into an unstructured vector.  Quite a lot
of validation is required to make sure that the intput has not
been tampered with, and errors thrown while doing this
validation may not be very interpretable.
\item \code{index}: The nested version of the \code{index()} function in
\code{\link[=monty_packer]{monty_packer()}}. The outer list is over groups, and the inner
list contains the position within the original unstructured
vector where this value can be found.  It is not clear to us if
this is a useful list.
\item \code{subset}: A function that might eventually allow subsetting a
grouped packer.  Currently it just errors.
}
}
\description{
Build a grouped version of \code{\link[=monty_packer]{monty_packer()}} with the same basic
idea; convert between a vector representation of some group of
numbers to a named list of structured data, but with an extra
twist: this time the unstructured vector of numbers contains
values that correspond to multiple \emph{groups} and some are shared
across groups while others vary between groups.  This function
does a lot of book keeping in a relatively short amount of code,
so you should be familiar with the ideas in \code{\link[=monty_packer]{monty_packer()}}
before continuing.
}
\details{
Recall from \code{\link[=monty_packer]{monty_packer()}} that our original problem was to take
an unstructured vector like

\if{html}{\out{<div class="sourceCode">}}\preformatted{| 1  2  3  4  5  6  7  |
| a  b  c  d1 d2 d3 d4 |
}\if{html}{\out{</div>}}

and \strong{unpack it} into a structured list like

\if{html}{\out{<div class="sourceCode r">}}\preformatted{list(a = 1, b = 2, c = 3, d = 4:7)
}\if{html}{\out{</div>}}

Our aim here is to the same but to allow some of these values (say
\code{b} and \code{c}) to be shared (constant) over groups while the others
(\code{a} and \code{d}) to vary by group.  So for groups \code{x} an \code{y} we might
try and create something like

\if{html}{\out{<div class="sourceCode r">}}\preformatted{list(
  list(x = list(a = 3, b = 1, c = 2, d = 4:7),
       y = list(a = 8, b = 1, c = 2, d = 9:12))
}\if{html}{\out{</div>}}

from a vector

\if{html}{\out{<div class="sourceCode">}}\preformatted{| 1  2  3  4  5  6  7  8  9  10 11 12 |
| b  c  a  d1 d2 d3 d4 a  d1 d2 d3 d4 |
| xy xy x  x  x  x  x  y  y  y  y  y  |
}\if{html}{\out{</div>}}
}
\examples{
p <- monty_packer_grouped(c("x", "y"), c("a", "b", "c", "d", "e"),
                          shared = c("b", "c"))
p$names()
p$unpack(1:8)
}
